<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>tikz.extended_wilkinson API documentation</title>
<meta name="description" content="Extended-Wilkinson algorithm for tick values and labels …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tikz.extended_wilkinson</code></h1>
</header>
<section id="section-intro">
<p>Extended-Wilkinson algorithm for tick values and labels</p>
<p>Implementation of J. Talbot, S. Lin, &amp; P. Hanrahan, An Extension of
Wilkinson’s Algorithm for Positioning Tick Labels on Axes, <em>IEEE Trans.
Vis. Comput. Graph.</em>, 16(6), 1036-1043, 2010.
<a href="https://doi.org/10.1109/tvcg.2010.130">doi:10.1109/TVCG.2010.130</a></p>
<p>Based on the
<a href="https://rdrr.io/rforge/labeling/src/R/labeling.R">R implementation</a>
and <a href="https://github.com/jtalbot/Labeling/issues/1">additional information</a>
by Justin Talbot.</p>
<p>Other than the R code, this implementation includes the <em>legibility</em> score,
and the result provides detailed information about the optimal presentation of
tick values as labels. In line with that, the parameter target number of ticks
<code>m</code> has been replaced by a target physical tick density (ρ<sub>t</sub> in the
paper).</p>
<p>Compared to the paper, there are two limitations: Of the eight label formats,
only 'Decimal' and 'Factored scientific' are implemented; and tick labels are
always '0-extended', i.e. if stripping of trailing zeros is desired, it must be
performed by the user.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Extended-Wilkinson algorithm for tick values and labels

Implementation of J. Talbot, S. Lin, &amp; P. Hanrahan, An Extension of
Wilkinson’s Algorithm for Positioning Tick Labels on Axes, *IEEE Trans.
Vis. Comput. Graph.*, 16(6), 1036-1043, 2010.
[doi:10.1109/TVCG.2010.130](https://doi.org/10.1109/tvcg.2010.130)

Based on the
[R implementation](https://rdrr.io/rforge/labeling/src/R/labeling.R)
and [additional information](https://github.com/jtalbot/Labeling/issues/1)
by Justin Talbot.

Other than the R code, this implementation includes the *legibility* score,
and the result provides detailed information about the optimal presentation of
tick values as labels. In line with that, the parameter target number of ticks
`m` has been replaced by a target physical tick density (ρ&lt;sub&gt;t&lt;/sub&gt; in the
paper).

Compared to the paper, there are two limitations: Of the eight label formats,
only &#39;Decimal&#39; and &#39;Factored scientific&#39; are implemented; and tick labels are
always &#39;0-extended&#39;, i.e. if stripping of trailing zeros is desired, it must be
performed by the user.
&#34;&#34;&#34;

# Copyright (C) 2020 Carsten Allefeld

from math import log10, ceil, floor
from itertools import count
from decimal import Decimal as D


class cfg:
    &#34;`tikz.extended_wilkinson` configuration variables&#34;

    Q = [D(1), D(5), D(2), D(&#39;2.5&#39;), D(4), D(3)]
    &#34;&#34;&#34;
    preference-ordered list of nice step sizes

    Values must be of type `decimal.Decimal`. The default step sizes are 1, 5,
    2, 2.5, 4, and 3.
    &#34;&#34;&#34;

    w = [0.25, 0.2, 0.5, 0.05]
    &#34;&#34;&#34;
    list of weights of score components

    The default weights are 0.25 for *simplicity*, 0.2 for *coverage*, 0.5 for
    *density*, and 0.05 for *legibility*.
    &#34;&#34;&#34;

    font_metrics = {&#39;offset&#39;: 0.1, &#39;-&#39;: 0.678, &#39;1&#39;: 0.5, &#39;2&#39;: 0.5, &#39;3&#39;: 0.5,
                    &#39;4&#39;: 0.5, &#39;5&#39;: 0.5, &#39;6&#39;: 0.5, &#39;7&#39;: 0.5, &#39;8&#39;: 0.5, &#39;9&#39;: 0.5,
                    &#39;0&#39;: 0.5, &#39;.&#39;: 0.278, &#39;height&#39;: 0.728}
    &#34;&#34;&#34;
    default font metrics

    Font metrics are used to calculate the width and height of tick labels.
    They are specified as a `dict`, where each character that can occur in a
    tick label (`&#39;-&#39;`, `&#39;0&#39;`–`&#39;9&#39;`, `&#39;.&#39;`) is a key associated with the
    character&#39;s width; it also contains an `&#39;offset&#39;` to be added to the total
    width, and a `&#39;height&#39;`. All numbers are in units of the font size.

    The default values are for La/TeX&#39;s standard math font (Computer Modern
    Roman).
    &#34;&#34;&#34;


class TicksGenerator:
    &#34;&#34;&#34;
    generator of tick values and labels

    This class stores parameters of tick generation that are likely to stay the
    same across several axes:

    `font_sizes`
    :   admissible font sizes, in TeX pt (2.54 cm / 72.27)

    `density`
    :   target density of ticks, in cm&lt;sup&gt;–1&lt;/sup&gt;

    `font_metrics`
    :   used to calculate the width and height of tick labels,
        see `cfg.font_metrics` (default)

    `only_loose`
    :   whether the range of tick values is forced to encompass the
      range of data values

    Ticks for a specific axis are generated by calling the
    [`ticks()`](#tikz.extended_wilkinson.TicksGenerator.ticks) method on an
    instance.
    &#34;&#34;&#34;

    def __init__(self, font_sizes, density,
                 font_metrics=None, only_loose=True):
        if font_metrics is None:
            font_metrics = cfg.font_metrics
        self.font_sizes = sorted(font_sizes)
        self.rt = density
        self.font_metrics = font_metrics
        self.only_loose = only_loose

    # scoring functions, including the approximations for limiting the search

    def _simplicity(self, i, start, j, k):
        # v: is zero included in the ticks?
        # modifications
        # - (lmin % lstep &lt; eps or lstep - (lmin % lstep) &lt; eps),
        #   means lmin / lstep = start / j is an integer
        # - lmin &lt;= 0 means start &lt;=0
        # - lmax &gt;= 0 means start + j * (k - 1) &gt;= 0
        v = (start % j == 0 and start &lt;= 0 and start + j * (k - 1) &gt;= 0) * 1
        return 1 - (i - 1) / (len(cfg.Q) - 1) - j + v

    def _simplicity_max(self, i, j):
        # upper bound on _simplicity w.r.t. k, z, start
        # = w.r.t. v
        return 1 - (i - 1) / (len(cfg.Q) - 1) - j + 1

    def _coverage(self, dmin, dmax, lmin, lmax):
        return (1 - 0.5 * ((dmax - lmax)**2 + (dmin - lmin)**2)
                / (0.1 * (dmax - dmin))**2)

    def _coverage_max(self, dmin, dmax, span):
        # upper bound on _coverage w.r.t. start
        range = dmax - dmin
        # The original code has a branching which I don&#39;t think is necessary.
        # if span &gt; range:
        #     half = (span - range) / 2
        #     return 1 - 0.5 * (2 * half ** 2) / (0.1 * range)**2
        # else:
        #     return 1
        half = (span - range) / 2
        return 1 - 0.5 * (2 * half ** 2) / (0.1 * range)**2

    def _density(self, k, m, dmin, dmax, lmin, lmax):
        r = (k - 1) / (lmax - lmin)
        rt = (m - 1) / (max(lmax, dmax) - min(dmin, lmin))
        return 2 - max((r / rt, rt / r))

    def _density_max(self, k, m):
        # From original code, which I don&#39;t understand.
        if k &gt;= m:
            return 2 - (k - 1) / (m - 1)
        else:
            # Probably just the trivial upper bound.
            return 1

    def _score(self, s, c, d, l):
        # combined score
        return cfg.w[0] * s + cfg.w[1] * c + cfg.w[2] * d + cfg.w[3] * l

    # optimization algorithm

    def ticks(self, dmin, dmax, axis_length, axis_horizontal):
        &#34;&#34;&#34;
        generate tick values and labels for a specific axis

        `dmin`
        :   data values lower bound

        `dmax`
        :   data values upper bound

        `axis_length`
        :   physical length of the axis, in cm

        `axis_horizontal`
        :   whether the axis is oriented horizontally (rather than vertically)

        Returns a `Ticks` object.
        &#34;&#34;&#34;

        # The implementation here is based on the R code, which is defined
        # in terms of `m`, the target number of ticks. It optimizes w.r.t.
        # the ratio between the two quantities
        #   r = (k - 1) / (lmax - lmin)
        #   rt = (m - 1) / (max(lmax, dmax) - min(dmin, lmin))
        # We want to instead specify the physical density (e.g. in 1/cm),
        # stored as a class attribute `self.rt`, and the parameter `length`
        # (e.g. in cm). Assuming that the axis spans `min(dmin, lmin)` to
        # `max(lmax, dmax)`, while the ticks span lmin to lmax, the
        # optimization should use the ratio of
        #   r = (k - 1) / (length * (lmax - lmin))
        #       * (max(lmax, dmax) - min(dmin, lmin))
        # to `self.rt`.
        # It turns out that the two ratios are equivalent if one sets
        m = self.rt * axis_length + 1

        if dmin &gt; dmax:
            dmin, dmax = dmax, dmin

        # threshold for optimization
        ticks = None
        best_score = -2

        # We combine the j and q loops into one to enable breaking out of both
        # simultaneously, by iterating over a generator; and we create an
        # index i corresponding to q at the same time. i is `match(q, Q)[1]`
        # and replaces `q, Q` in function calls.
        JIQ = ((j, i, q)
               for j in count(start=1)
               for i, q in enumerate(cfg.Q, start=1))
        for j, i, q in JIQ:
            sm = self._simplicity_max(i, j)

            if self._score(sm, 1, 1, 1) &lt; best_score:
                break

            for k in count(start=2):      # loop over tick counts
                dm = self._density_max(k, m)

                if self._score(sm, 1, dm, 1) &lt; best_score:
                    break

                delta = (dmax - dmin) / (k + 1) / (j * float(q))

                for z in count(start=ceil(log10(delta))):
                    step = float(q) * j * 10**z

                    cm = self._coverage_max(dmin, dmax, step * (k - 1))

                    if self._score(sm, cm, dm, 1) &lt; best_score:
                        break

                    min_start = floor(dmax / step) * j - (k - 1) * j
                    max_start = ceil(dmin / step) * j

                    if min_start &gt; max_start:
                        continue

                    for start in range(min_start, max_start + 1):
                        lmin = start * step / j
                        lmax = lmin + step * (k - 1)
                        # lstep = step

                        if self.only_loose:
                            if lmin &gt; dmin or lmax &lt; dmax:
                                continue

                        s = self._simplicity(i, start, j, k)
                        c = self._coverage(dmin, dmax, lmin, lmax)
                        d = self._density(k, m, dmin, dmax, lmin, lmax)

                        score = self._score(s, c, d, 1)

                        if score &lt; best_score:
                            continue

                        # Exact tick values in terms of loop variables:
                        #   lmin = q * start * 10**z
                        #   lmax = q * (start + j * (k - 1)) * 10 ** z
                        #   lstep = float(q) * j * 10**z
                        decimal_values = [q * (start + j * ind)
                                          * D(&#39;1E1&#39;) ** z
                                          for ind in range(k)]

                        # Create `Ticks` object
                        ticks = Ticks(
                            amin=min(lmin, dmin),
                            amax=max(lmax, dmax),
                            decimal_values=decimal_values)
                        # and initiate internal optimization for label
                        # legibility.
                        ticks._optimize(
                            self.font_sizes,
                            self.font_metrics,
                            axis_length,
                            axis_horizontal)

                        l = ticks.opt_legibility                                    # noqa E741

                        score = self._score(s, c, d, l)

                        if score &gt; best_score:
                            best_score = score

        if ticks is None:
            # no solution found: no ticks
            print(&#39;Warning: Could not determine ticks.&#39;)
            ticks = Ticks(
                amin=dmin,
                amax=dmax,
                decimal_values=[],
                labels=[])
        return ticks


class Ticks:
    &#34;&#34;&#34;
    represents tick values and labels

    This class is not intended to be instantiated by the user, but
    `Ticks` objects are obtained via `TicksGenerator.ticks`.
    &#34;&#34;&#34;

    def __init__(self, amin, amax, decimal_values,
                 labels=None, plabel=None, font_size=None, horizontal=None):
        self.amin = amin
        &#34;axis lower bound&#34;

        self.amax = amax
        &#34;axis upper bound&#34;

        self.values = [float(dv) for dv in decimal_values]
        &#34;list of tick values&#34;

        self.decimal_values = decimal_values
        &#34;list of exact tick values, as `decimal.Decimal`s&#34;

        self.labels = labels
        &#34;list of tick labels strings&#34;

        self.plabel = plabel
        &#34;&#34;&#34;
        power label string

        If `plabel` is not `None`, it represents a decadic power factored from
        the tick values. It is intended to be displayed in the form
        10&lt;sup&gt;`plabel`&lt;/sup&gt; either at the side of the axis or as/with a unit
        in the axis label.
        &#34;&#34;&#34;

        self.font_size = font_size
        &#34;tick label font size, in TeX pt (2.54 cm / 72.27)&#34;

        self.horizontal = horizontal
        &#34;&#34;&#34;
        whether the tick label is to be displayed in horizontal orientation
        (rather than vertical)
        &#34;&#34;&#34;

    def _optimize(self, font_sizes, font_metrics,
                  axis_length, axis_horizontal):
        &#34;&#34;&#34;
        optimize label legibility in terms of format, font size, and
        orientation
        &#34;&#34;&#34;

        # tick values
        values = self.values
        # minimum font size
        fs_min = min(font_sizes)
        # target font size
        fs_t = max(font_sizes)

        # optimization
        self.opt_legibility = float(&#39;-inf&#39;)
        # format
        for f in range(2):
            # legibility score for format
            if f == 0:
                # format &#39;Decimal&#39;
                vls = [(1e-4 &lt; abs(v) &lt; 1e6) * 1 for v in values]
                leg_f = sum(vls) / len(vls)
            else:
                # format &#39;Factored scientific&#39;
                leg_f = 0.3

            # tick labels
            if f == 0:
                # format &#39;Decimal&#39;
                labels = self._labels_Decimal()
                plabel = None
            else:
                # format &#39;Factored scientific&#39;
                labels, plabel = self._labels_Scientific()

            # widths and heights of tick labels, in units of font size
            widths = [self._label_width(l, font_metrics) for l in labels]
            heights = [self._label_height(l, font_metrics) for l in labels]

            # font size
            for fs in font_sizes:
                # legibility score for font size
                if fs == fs_t:
                    leg_fs = 1
                else:
                    leg_fs = 0.2 * (fs - fs_min + 1) / (fs_t - fs_min)

                # distance between ticks, in units of font size
                step = (
                    (values[1] - values[0])         # numerical
                    / (self.amax - self.amin)       # relative to axis
                    * axis_length                   # physical, in cm
                    /
                    (fs / 72.27 * 2.54)             # font size, in cm
                    )

                # orientation
                for o in range(2):
                    # legibility score for orientation
                    if o == 0:              # horizontal orientation
                        leg_or = 1
                    else:                   # vertical orientation
                        leg_or = -0.5

                    # legibility score for overlap
                    # extents of labels along the axis, in units of font size
                    if (o == 0) == axis_horizontal:
                        # label and axis have the same orientation
                        extents = widths
                    else:
                        # label and axis have different orientations
                        extents = heights
                    # minimum distance between neighboring labels
                    # We can apply the minimum here, since overlap legibility
                    # is an increasing function of distance.
                    dist = min(step - (extents[i] + extents[i + 1]) / 2
                               for i in range(len(extents) - 1))
                    # score; we interpret em as font size
                    if dist &gt;= 1.5:
                        leg_ov = 1
                    elif dist &gt; 0:
                        leg_ov = 2 - 1.5 / dist
                    else:
                        leg_ov = float(&#39;-inf&#39;)

                    # total legibility score
                    leg = (leg_f + leg_fs + leg_or + leg_ov) / 4

                    # aggregate
                    if leg &gt; self.opt_legibility:
                        self.opt_legibility = leg
                        self.labels = labels
                        self.plabel = plabel
                        self.font_size = fs
                        self.horizontal = (o == 0)

    def _label_width(self, label, font_metrics):
        &#34;get width of tick label&#34;

        w = sum(map(font_metrics.get, label)) + font_metrics[&#39;offset&#39;]
        return w

    def _label_height(self, label, font_metrics):
        &#34;get height of tick label&#34;

        h = font_metrics[&#39;height&#39;]
        return h

    def _labels_Decimal(self):
        &#34;get tick labels in &#39;Decimal&#39; format&#34;

        # get values
        dvs = self.decimal_values
        # create labels
        labels = [&#39;{:f}&#39;.format(dv) for dv in dvs]
        return labels

    def _labels_Scientific(self):
        &#34;get tick labels in &#39;Scientific format&#39;&#34;

        # get values
        dvs = self.decimal_values
        # get largest power of 10 than can be factored out
        z0 = min([floor(log10(abs(dv))) for dv in dvs if dv != 0])
        # get values adjusted to that power
        dvs = [dv * D(&#39;1E1&#39;) ** (-z0) for dv in dvs]
        # create labels
        labels = [&#39;{:f}&#39;.format(dv) for dv in dvs]
        plabel = &#39;{:d}&#39;.format(z0)
        return labels, plabel</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tikz.extended_wilkinson.cfg"><code class="flex name class">
<span>class <span class="ident">cfg</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p><a title="tikz.extended_wilkinson" href="#tikz.extended_wilkinson"><code>tikz.extended_wilkinson</code></a> configuration variables</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class cfg:
    &#34;`tikz.extended_wilkinson` configuration variables&#34;

    Q = [D(1), D(5), D(2), D(&#39;2.5&#39;), D(4), D(3)]
    &#34;&#34;&#34;
    preference-ordered list of nice step sizes

    Values must be of type `decimal.Decimal`. The default step sizes are 1, 5,
    2, 2.5, 4, and 3.
    &#34;&#34;&#34;

    w = [0.25, 0.2, 0.5, 0.05]
    &#34;&#34;&#34;
    list of weights of score components

    The default weights are 0.25 for *simplicity*, 0.2 for *coverage*, 0.5 for
    *density*, and 0.05 for *legibility*.
    &#34;&#34;&#34;

    font_metrics = {&#39;offset&#39;: 0.1, &#39;-&#39;: 0.678, &#39;1&#39;: 0.5, &#39;2&#39;: 0.5, &#39;3&#39;: 0.5,
                    &#39;4&#39;: 0.5, &#39;5&#39;: 0.5, &#39;6&#39;: 0.5, &#39;7&#39;: 0.5, &#39;8&#39;: 0.5, &#39;9&#39;: 0.5,
                    &#39;0&#39;: 0.5, &#39;.&#39;: 0.278, &#39;height&#39;: 0.728}
    &#34;&#34;&#34;
    default font metrics

    Font metrics are used to calculate the width and height of tick labels.
    They are specified as a `dict`, where each character that can occur in a
    tick label (`&#39;-&#39;`, `&#39;0&#39;`–`&#39;9&#39;`, `&#39;.&#39;`) is a key associated with the
    character&#39;s width; it also contains an `&#39;offset&#39;` to be added to the total
    width, and a `&#39;height&#39;`. All numbers are in units of the font size.

    The default values are for La/TeX&#39;s standard math font (Computer Modern
    Roman).
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tikz.extended_wilkinson.cfg.Q"><code class="name">var <span class="ident">Q</span></code></dt>
<dd>
<section class="desc"><p>preference-ordered list of nice step sizes</p>
<p>Values must be of type <code>decimal.Decimal</code>. The default step sizes are 1, 5,
2, 2.5, 4, and 3.</p></section>
</dd>
<dt id="tikz.extended_wilkinson.cfg.w"><code class="name">var <span class="ident">w</span></code></dt>
<dd>
<section class="desc"><p>list of weights of score components</p>
<p>The default weights are 0.25 for <em>simplicity</em>, 0.2 for <em>coverage</em>, 0.5 for
<em>density</em>, and 0.05 for <em>legibility</em>.</p></section>
</dd>
<dt id="tikz.extended_wilkinson.cfg.font_metrics"><code class="name">var <span class="ident">font_metrics</span></code></dt>
<dd>
<section class="desc"><p>default font metrics</p>
<p>Font metrics are used to calculate the width and height of tick labels.
They are specified as a <code>dict</code>, where each character that can occur in a
tick label (<code>'-'</code>, <code>'0'</code>–<code>'9'</code>, <code>'.'</code>) is a key associated with the
character's width; it also contains an <code>'offset'</code> to be added to the total
width, and a <code>'height'</code>. All numbers are in units of the font size.</p>
<p>The default values are for La/TeX's standard math font (Computer Modern
Roman).</p></section>
</dd>
</dl>
</dd>
<dt id="tikz.extended_wilkinson.TicksGenerator"><code class="flex name class">
<span>class <span class="ident">TicksGenerator</span></span>
<span>(</span><span>font_sizes, density, font_metrics=None, only_loose=True)</span>
</code></dt>
<dd>
<section class="desc"><p>generator of tick values and labels</p>
<p>This class stores parameters of tick generation that are likely to stay the
same across several axes:</p>
<dl>
<dt><code>font_sizes</code></dt>
<dd>admissible font sizes, in TeX pt (2.54 cm / 72.27)</dd>
<dt><code>density</code></dt>
<dd>target density of ticks, in cm<sup>–1</sup></dd>
<dt><code>font_metrics</code></dt>
<dd>used to calculate the width and height of tick labels,
see <a title="tikz.extended_wilkinson.cfg.font_metrics" href="#tikz.extended_wilkinson.cfg.font_metrics"><code>cfg.font_metrics</code></a> (default)</dd>
<dt><code>only_loose</code></dt>
<dd>whether the range of tick values is forced to encompass the
range of data values</dd>
</dl>
<p>Ticks for a specific axis are generated by calling the
<a href="#tikz.extended_wilkinson.TicksGenerator.ticks"><code>ticks()</code></a> method on an
instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TicksGenerator:
    &#34;&#34;&#34;
    generator of tick values and labels

    This class stores parameters of tick generation that are likely to stay the
    same across several axes:

    `font_sizes`
    :   admissible font sizes, in TeX pt (2.54 cm / 72.27)

    `density`
    :   target density of ticks, in cm&lt;sup&gt;–1&lt;/sup&gt;

    `font_metrics`
    :   used to calculate the width and height of tick labels,
        see `cfg.font_metrics` (default)

    `only_loose`
    :   whether the range of tick values is forced to encompass the
      range of data values

    Ticks for a specific axis are generated by calling the
    [`ticks()`](#tikz.extended_wilkinson.TicksGenerator.ticks) method on an
    instance.
    &#34;&#34;&#34;

    def __init__(self, font_sizes, density,
                 font_metrics=None, only_loose=True):
        if font_metrics is None:
            font_metrics = cfg.font_metrics
        self.font_sizes = sorted(font_sizes)
        self.rt = density
        self.font_metrics = font_metrics
        self.only_loose = only_loose

    # scoring functions, including the approximations for limiting the search

    def _simplicity(self, i, start, j, k):
        # v: is zero included in the ticks?
        # modifications
        # - (lmin % lstep &lt; eps or lstep - (lmin % lstep) &lt; eps),
        #   means lmin / lstep = start / j is an integer
        # - lmin &lt;= 0 means start &lt;=0
        # - lmax &gt;= 0 means start + j * (k - 1) &gt;= 0
        v = (start % j == 0 and start &lt;= 0 and start + j * (k - 1) &gt;= 0) * 1
        return 1 - (i - 1) / (len(cfg.Q) - 1) - j + v

    def _simplicity_max(self, i, j):
        # upper bound on _simplicity w.r.t. k, z, start
        # = w.r.t. v
        return 1 - (i - 1) / (len(cfg.Q) - 1) - j + 1

    def _coverage(self, dmin, dmax, lmin, lmax):
        return (1 - 0.5 * ((dmax - lmax)**2 + (dmin - lmin)**2)
                / (0.1 * (dmax - dmin))**2)

    def _coverage_max(self, dmin, dmax, span):
        # upper bound on _coverage w.r.t. start
        range = dmax - dmin
        # The original code has a branching which I don&#39;t think is necessary.
        # if span &gt; range:
        #     half = (span - range) / 2
        #     return 1 - 0.5 * (2 * half ** 2) / (0.1 * range)**2
        # else:
        #     return 1
        half = (span - range) / 2
        return 1 - 0.5 * (2 * half ** 2) / (0.1 * range)**2

    def _density(self, k, m, dmin, dmax, lmin, lmax):
        r = (k - 1) / (lmax - lmin)
        rt = (m - 1) / (max(lmax, dmax) - min(dmin, lmin))
        return 2 - max((r / rt, rt / r))

    def _density_max(self, k, m):
        # From original code, which I don&#39;t understand.
        if k &gt;= m:
            return 2 - (k - 1) / (m - 1)
        else:
            # Probably just the trivial upper bound.
            return 1

    def _score(self, s, c, d, l):
        # combined score
        return cfg.w[0] * s + cfg.w[1] * c + cfg.w[2] * d + cfg.w[3] * l

    # optimization algorithm

    def ticks(self, dmin, dmax, axis_length, axis_horizontal):
        &#34;&#34;&#34;
        generate tick values and labels for a specific axis

        `dmin`
        :   data values lower bound

        `dmax`
        :   data values upper bound

        `axis_length`
        :   physical length of the axis, in cm

        `axis_horizontal`
        :   whether the axis is oriented horizontally (rather than vertically)

        Returns a `Ticks` object.
        &#34;&#34;&#34;

        # The implementation here is based on the R code, which is defined
        # in terms of `m`, the target number of ticks. It optimizes w.r.t.
        # the ratio between the two quantities
        #   r = (k - 1) / (lmax - lmin)
        #   rt = (m - 1) / (max(lmax, dmax) - min(dmin, lmin))
        # We want to instead specify the physical density (e.g. in 1/cm),
        # stored as a class attribute `self.rt`, and the parameter `length`
        # (e.g. in cm). Assuming that the axis spans `min(dmin, lmin)` to
        # `max(lmax, dmax)`, while the ticks span lmin to lmax, the
        # optimization should use the ratio of
        #   r = (k - 1) / (length * (lmax - lmin))
        #       * (max(lmax, dmax) - min(dmin, lmin))
        # to `self.rt`.
        # It turns out that the two ratios are equivalent if one sets
        m = self.rt * axis_length + 1

        if dmin &gt; dmax:
            dmin, dmax = dmax, dmin

        # threshold for optimization
        ticks = None
        best_score = -2

        # We combine the j and q loops into one to enable breaking out of both
        # simultaneously, by iterating over a generator; and we create an
        # index i corresponding to q at the same time. i is `match(q, Q)[1]`
        # and replaces `q, Q` in function calls.
        JIQ = ((j, i, q)
               for j in count(start=1)
               for i, q in enumerate(cfg.Q, start=1))
        for j, i, q in JIQ:
            sm = self._simplicity_max(i, j)

            if self._score(sm, 1, 1, 1) &lt; best_score:
                break

            for k in count(start=2):      # loop over tick counts
                dm = self._density_max(k, m)

                if self._score(sm, 1, dm, 1) &lt; best_score:
                    break

                delta = (dmax - dmin) / (k + 1) / (j * float(q))

                for z in count(start=ceil(log10(delta))):
                    step = float(q) * j * 10**z

                    cm = self._coverage_max(dmin, dmax, step * (k - 1))

                    if self._score(sm, cm, dm, 1) &lt; best_score:
                        break

                    min_start = floor(dmax / step) * j - (k - 1) * j
                    max_start = ceil(dmin / step) * j

                    if min_start &gt; max_start:
                        continue

                    for start in range(min_start, max_start + 1):
                        lmin = start * step / j
                        lmax = lmin + step * (k - 1)
                        # lstep = step

                        if self.only_loose:
                            if lmin &gt; dmin or lmax &lt; dmax:
                                continue

                        s = self._simplicity(i, start, j, k)
                        c = self._coverage(dmin, dmax, lmin, lmax)
                        d = self._density(k, m, dmin, dmax, lmin, lmax)

                        score = self._score(s, c, d, 1)

                        if score &lt; best_score:
                            continue

                        # Exact tick values in terms of loop variables:
                        #   lmin = q * start * 10**z
                        #   lmax = q * (start + j * (k - 1)) * 10 ** z
                        #   lstep = float(q) * j * 10**z
                        decimal_values = [q * (start + j * ind)
                                          * D(&#39;1E1&#39;) ** z
                                          for ind in range(k)]

                        # Create `Ticks` object
                        ticks = Ticks(
                            amin=min(lmin, dmin),
                            amax=max(lmax, dmax),
                            decimal_values=decimal_values)
                        # and initiate internal optimization for label
                        # legibility.
                        ticks._optimize(
                            self.font_sizes,
                            self.font_metrics,
                            axis_length,
                            axis_horizontal)

                        l = ticks.opt_legibility                                    # noqa E741

                        score = self._score(s, c, d, l)

                        if score &gt; best_score:
                            best_score = score

        if ticks is None:
            # no solution found: no ticks
            print(&#39;Warning: Could not determine ticks.&#39;)
            ticks = Ticks(
                amin=dmin,
                amax=dmax,
                decimal_values=[],
                labels=[])
        return ticks</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tikz.extended_wilkinson.TicksGenerator.ticks"><code class="name flex">
<span>def <span class="ident">ticks</span></span>(<span>self, dmin, dmax, axis_length, axis_horizontal)</span>
</code></dt>
<dd>
<section class="desc"><p>generate tick values and labels for a specific axis</p>
<dl>
<dt><code>dmin</code></dt>
<dd>data values lower bound</dd>
<dt><code>dmax</code></dt>
<dd>data values upper bound</dd>
<dt><code>axis_length</code></dt>
<dd>physical length of the axis, in cm</dd>
<dt><code>axis_horizontal</code></dt>
<dd>whether the axis is oriented horizontally (rather than vertically)</dd>
</dl>
<p>Returns a <a title="tikz.extended_wilkinson.Ticks" href="#tikz.extended_wilkinson.Ticks"><code>Ticks</code></a> object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ticks(self, dmin, dmax, axis_length, axis_horizontal):
    &#34;&#34;&#34;
    generate tick values and labels for a specific axis

    `dmin`
    :   data values lower bound

    `dmax`
    :   data values upper bound

    `axis_length`
    :   physical length of the axis, in cm

    `axis_horizontal`
    :   whether the axis is oriented horizontally (rather than vertically)

    Returns a `Ticks` object.
    &#34;&#34;&#34;

    # The implementation here is based on the R code, which is defined
    # in terms of `m`, the target number of ticks. It optimizes w.r.t.
    # the ratio between the two quantities
    #   r = (k - 1) / (lmax - lmin)
    #   rt = (m - 1) / (max(lmax, dmax) - min(dmin, lmin))
    # We want to instead specify the physical density (e.g. in 1/cm),
    # stored as a class attribute `self.rt`, and the parameter `length`
    # (e.g. in cm). Assuming that the axis spans `min(dmin, lmin)` to
    # `max(lmax, dmax)`, while the ticks span lmin to lmax, the
    # optimization should use the ratio of
    #   r = (k - 1) / (length * (lmax - lmin))
    #       * (max(lmax, dmax) - min(dmin, lmin))
    # to `self.rt`.
    # It turns out that the two ratios are equivalent if one sets
    m = self.rt * axis_length + 1

    if dmin &gt; dmax:
        dmin, dmax = dmax, dmin

    # threshold for optimization
    ticks = None
    best_score = -2

    # We combine the j and q loops into one to enable breaking out of both
    # simultaneously, by iterating over a generator; and we create an
    # index i corresponding to q at the same time. i is `match(q, Q)[1]`
    # and replaces `q, Q` in function calls.
    JIQ = ((j, i, q)
           for j in count(start=1)
           for i, q in enumerate(cfg.Q, start=1))
    for j, i, q in JIQ:
        sm = self._simplicity_max(i, j)

        if self._score(sm, 1, 1, 1) &lt; best_score:
            break

        for k in count(start=2):      # loop over tick counts
            dm = self._density_max(k, m)

            if self._score(sm, 1, dm, 1) &lt; best_score:
                break

            delta = (dmax - dmin) / (k + 1) / (j * float(q))

            for z in count(start=ceil(log10(delta))):
                step = float(q) * j * 10**z

                cm = self._coverage_max(dmin, dmax, step * (k - 1))

                if self._score(sm, cm, dm, 1) &lt; best_score:
                    break

                min_start = floor(dmax / step) * j - (k - 1) * j
                max_start = ceil(dmin / step) * j

                if min_start &gt; max_start:
                    continue

                for start in range(min_start, max_start + 1):
                    lmin = start * step / j
                    lmax = lmin + step * (k - 1)
                    # lstep = step

                    if self.only_loose:
                        if lmin &gt; dmin or lmax &lt; dmax:
                            continue

                    s = self._simplicity(i, start, j, k)
                    c = self._coverage(dmin, dmax, lmin, lmax)
                    d = self._density(k, m, dmin, dmax, lmin, lmax)

                    score = self._score(s, c, d, 1)

                    if score &lt; best_score:
                        continue

                    # Exact tick values in terms of loop variables:
                    #   lmin = q * start * 10**z
                    #   lmax = q * (start + j * (k - 1)) * 10 ** z
                    #   lstep = float(q) * j * 10**z
                    decimal_values = [q * (start + j * ind)
                                      * D(&#39;1E1&#39;) ** z
                                      for ind in range(k)]

                    # Create `Ticks` object
                    ticks = Ticks(
                        amin=min(lmin, dmin),
                        amax=max(lmax, dmax),
                        decimal_values=decimal_values)
                    # and initiate internal optimization for label
                    # legibility.
                    ticks._optimize(
                        self.font_sizes,
                        self.font_metrics,
                        axis_length,
                        axis_horizontal)

                    l = ticks.opt_legibility                                    # noqa E741

                    score = self._score(s, c, d, l)

                    if score &gt; best_score:
                        best_score = score

    if ticks is None:
        # no solution found: no ticks
        print(&#39;Warning: Could not determine ticks.&#39;)
        ticks = Ticks(
            amin=dmin,
            amax=dmax,
            decimal_values=[],
            labels=[])
    return ticks</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tikz.extended_wilkinson.Ticks"><code class="flex name class">
<span>class <span class="ident">Ticks</span></span>
<span>(</span><span>amin, amax, decimal_values, labels=None, plabel=None, font_size=None, horizontal=None)</span>
</code></dt>
<dd>
<section class="desc"><p>represents tick values and labels</p>
<p>This class is not intended to be instantiated by the user, but
<a title="tikz.extended_wilkinson.Ticks" href="#tikz.extended_wilkinson.Ticks"><code>Ticks</code></a> objects are obtained via <a title="tikz.extended_wilkinson.TicksGenerator.ticks" href="#tikz.extended_wilkinson.TicksGenerator.ticks"><code>TicksGenerator.ticks()</code></a>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ticks:
    &#34;&#34;&#34;
    represents tick values and labels

    This class is not intended to be instantiated by the user, but
    `Ticks` objects are obtained via `TicksGenerator.ticks`.
    &#34;&#34;&#34;

    def __init__(self, amin, amax, decimal_values,
                 labels=None, plabel=None, font_size=None, horizontal=None):
        self.amin = amin
        &#34;axis lower bound&#34;

        self.amax = amax
        &#34;axis upper bound&#34;

        self.values = [float(dv) for dv in decimal_values]
        &#34;list of tick values&#34;

        self.decimal_values = decimal_values
        &#34;list of exact tick values, as `decimal.Decimal`s&#34;

        self.labels = labels
        &#34;list of tick labels strings&#34;

        self.plabel = plabel
        &#34;&#34;&#34;
        power label string

        If `plabel` is not `None`, it represents a decadic power factored from
        the tick values. It is intended to be displayed in the form
        10&lt;sup&gt;`plabel`&lt;/sup&gt; either at the side of the axis or as/with a unit
        in the axis label.
        &#34;&#34;&#34;

        self.font_size = font_size
        &#34;tick label font size, in TeX pt (2.54 cm / 72.27)&#34;

        self.horizontal = horizontal
        &#34;&#34;&#34;
        whether the tick label is to be displayed in horizontal orientation
        (rather than vertical)
        &#34;&#34;&#34;

    def _optimize(self, font_sizes, font_metrics,
                  axis_length, axis_horizontal):
        &#34;&#34;&#34;
        optimize label legibility in terms of format, font size, and
        orientation
        &#34;&#34;&#34;

        # tick values
        values = self.values
        # minimum font size
        fs_min = min(font_sizes)
        # target font size
        fs_t = max(font_sizes)

        # optimization
        self.opt_legibility = float(&#39;-inf&#39;)
        # format
        for f in range(2):
            # legibility score for format
            if f == 0:
                # format &#39;Decimal&#39;
                vls = [(1e-4 &lt; abs(v) &lt; 1e6) * 1 for v in values]
                leg_f = sum(vls) / len(vls)
            else:
                # format &#39;Factored scientific&#39;
                leg_f = 0.3

            # tick labels
            if f == 0:
                # format &#39;Decimal&#39;
                labels = self._labels_Decimal()
                plabel = None
            else:
                # format &#39;Factored scientific&#39;
                labels, plabel = self._labels_Scientific()

            # widths and heights of tick labels, in units of font size
            widths = [self._label_width(l, font_metrics) for l in labels]
            heights = [self._label_height(l, font_metrics) for l in labels]

            # font size
            for fs in font_sizes:
                # legibility score for font size
                if fs == fs_t:
                    leg_fs = 1
                else:
                    leg_fs = 0.2 * (fs - fs_min + 1) / (fs_t - fs_min)

                # distance between ticks, in units of font size
                step = (
                    (values[1] - values[0])         # numerical
                    / (self.amax - self.amin)       # relative to axis
                    * axis_length                   # physical, in cm
                    /
                    (fs / 72.27 * 2.54)             # font size, in cm
                    )

                # orientation
                for o in range(2):
                    # legibility score for orientation
                    if o == 0:              # horizontal orientation
                        leg_or = 1
                    else:                   # vertical orientation
                        leg_or = -0.5

                    # legibility score for overlap
                    # extents of labels along the axis, in units of font size
                    if (o == 0) == axis_horizontal:
                        # label and axis have the same orientation
                        extents = widths
                    else:
                        # label and axis have different orientations
                        extents = heights
                    # minimum distance between neighboring labels
                    # We can apply the minimum here, since overlap legibility
                    # is an increasing function of distance.
                    dist = min(step - (extents[i] + extents[i + 1]) / 2
                               for i in range(len(extents) - 1))
                    # score; we interpret em as font size
                    if dist &gt;= 1.5:
                        leg_ov = 1
                    elif dist &gt; 0:
                        leg_ov = 2 - 1.5 / dist
                    else:
                        leg_ov = float(&#39;-inf&#39;)

                    # total legibility score
                    leg = (leg_f + leg_fs + leg_or + leg_ov) / 4

                    # aggregate
                    if leg &gt; self.opt_legibility:
                        self.opt_legibility = leg
                        self.labels = labels
                        self.plabel = plabel
                        self.font_size = fs
                        self.horizontal = (o == 0)

    def _label_width(self, label, font_metrics):
        &#34;get width of tick label&#34;

        w = sum(map(font_metrics.get, label)) + font_metrics[&#39;offset&#39;]
        return w

    def _label_height(self, label, font_metrics):
        &#34;get height of tick label&#34;

        h = font_metrics[&#39;height&#39;]
        return h

    def _labels_Decimal(self):
        &#34;get tick labels in &#39;Decimal&#39; format&#34;

        # get values
        dvs = self.decimal_values
        # create labels
        labels = [&#39;{:f}&#39;.format(dv) for dv in dvs]
        return labels

    def _labels_Scientific(self):
        &#34;get tick labels in &#39;Scientific format&#39;&#34;

        # get values
        dvs = self.decimal_values
        # get largest power of 10 than can be factored out
        z0 = min([floor(log10(abs(dv))) for dv in dvs if dv != 0])
        # get values adjusted to that power
        dvs = [dv * D(&#39;1E1&#39;) ** (-z0) for dv in dvs]
        # create labels
        labels = [&#39;{:f}&#39;.format(dv) for dv in dvs]
        plabel = &#39;{:d}&#39;.format(z0)
        return labels, plabel</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tikz.extended_wilkinson.Ticks.amin"><code class="name">var <span class="ident">amin</span></code></dt>
<dd>
<section class="desc"><p>axis lower bound</p></section>
</dd>
<dt id="tikz.extended_wilkinson.Ticks.amax"><code class="name">var <span class="ident">amax</span></code></dt>
<dd>
<section class="desc"><p>axis upper bound</p></section>
</dd>
<dt id="tikz.extended_wilkinson.Ticks.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<section class="desc"><p>list of tick values</p></section>
</dd>
<dt id="tikz.extended_wilkinson.Ticks.decimal_values"><code class="name">var <span class="ident">decimal_values</span></code></dt>
<dd>
<section class="desc"><p>list of exact tick values, as <code>decimal.Decimal</code>s</p></section>
</dd>
<dt id="tikz.extended_wilkinson.Ticks.labels"><code class="name">var <span class="ident">labels</span></code></dt>
<dd>
<section class="desc"><p>list of tick labels strings</p></section>
</dd>
<dt id="tikz.extended_wilkinson.Ticks.plabel"><code class="name">var <span class="ident">plabel</span></code></dt>
<dd>
<section class="desc"><p>power label string</p>
<p>If <code>plabel</code> is not <code>None</code>, it represents a decadic power factored from
the tick values. It is intended to be displayed in the form
10<sup><code>plabel</code></sup> either at the side of the axis or as/with a unit
in the axis label.</p></section>
</dd>
<dt id="tikz.extended_wilkinson.Ticks.font_size"><code class="name">var <span class="ident">font_size</span></code></dt>
<dd>
<section class="desc"><p>tick label font size, in TeX pt (2.54 cm / 72.27)</p></section>
</dd>
<dt id="tikz.extended_wilkinson.Ticks.horizontal"><code class="name">var <span class="ident">horizontal</span></code></dt>
<dd>
<section class="desc"><p>whether the tick label is to be displayed in horizontal orientation
(rather than vertical)</p></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<a href="https://github.com/allefeld/pytikz">
<img src="../logo.png"
style="width:100%;padding-left:40px;padding-right:40px">
</a>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tikz" href="index.html">tikz</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tikz.extended_wilkinson.cfg" href="#tikz.extended_wilkinson.cfg">cfg</a></code></h4>
<ul class="">
<li><code><a title="tikz.extended_wilkinson.cfg.Q" href="#tikz.extended_wilkinson.cfg.Q">Q</a></code></li>
<li><code><a title="tikz.extended_wilkinson.cfg.w" href="#tikz.extended_wilkinson.cfg.w">w</a></code></li>
<li><code><a title="tikz.extended_wilkinson.cfg.font_metrics" href="#tikz.extended_wilkinson.cfg.font_metrics">font_metrics</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tikz.extended_wilkinson.TicksGenerator" href="#tikz.extended_wilkinson.TicksGenerator">TicksGenerator</a></code></h4>
<ul class="">
<li><code><a title="tikz.extended_wilkinson.TicksGenerator.ticks" href="#tikz.extended_wilkinson.TicksGenerator.ticks">ticks</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tikz.extended_wilkinson.Ticks" href="#tikz.extended_wilkinson.Ticks">Ticks</a></code></h4>
<ul class="two-column">
<li><code><a title="tikz.extended_wilkinson.Ticks.amin" href="#tikz.extended_wilkinson.Ticks.amin">amin</a></code></li>
<li><code><a title="tikz.extended_wilkinson.Ticks.amax" href="#tikz.extended_wilkinson.Ticks.amax">amax</a></code></li>
<li><code><a title="tikz.extended_wilkinson.Ticks.values" href="#tikz.extended_wilkinson.Ticks.values">values</a></code></li>
<li><code><a title="tikz.extended_wilkinson.Ticks.decimal_values" href="#tikz.extended_wilkinson.Ticks.decimal_values">decimal_values</a></code></li>
<li><code><a title="tikz.extended_wilkinson.Ticks.labels" href="#tikz.extended_wilkinson.Ticks.labels">labels</a></code></li>
<li><code><a title="tikz.extended_wilkinson.Ticks.plabel" href="#tikz.extended_wilkinson.Ticks.plabel">plabel</a></code></li>
<li><code><a title="tikz.extended_wilkinson.Ticks.font_size" href="#tikz.extended_wilkinson.Ticks.font_size">font_size</a></code></li>
<li><code><a title="tikz.extended_wilkinson.Ticks.horizontal" href="#tikz.extended_wilkinson.Ticks.horizontal">horizontal</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>